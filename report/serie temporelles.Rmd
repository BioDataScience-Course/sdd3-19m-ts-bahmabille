---
title: "Série spatio-temporelle"
author: "Guyliann Engels & Philippe Grosjean"
output: github_document
---


## Objectifs

Nous attendons des rapports individuels liés à chaque situation présentée précédement sous le format d'un R Markdown ( format de sortie libre). Il ne s'agit pas de rapports scientifiques conventionnels dont vous connaissez bien la structure (introduction, matériels & méthodes, but, ....).

Vous devez considérer ces rapports comme des carnets de laboratoires. Lors d'une expérience, tout est consigné dans le carnet de laboratoire.

Votre rapport doit respecter la logique suivante :

- But : Quelle est la question que vous vous posez ? Cette information se trouve dans la section ci-dessus.


- Analyse : Cette section doit montrer l'évolution de votre analyse des données. Chaque graphiqe ou chaque modèle doit être commenté dans le texte en dessous de ce dernier.


**Note :** Les données sont mises à votre disposition au sein du dépôt dans le dossier data

## Contexte

11 analyses vous sont demandées dont les contextes vous sont expliqués ci-dessous.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#??????????
```


### Croissance d'arbres

Les scientifiques mesurent l'épaisseur de cernes (en cm) sur des arbres abattus en 1973. Décomposez cette série avec la méthode des moyennes mobiles

```{r,fig.align='center', echo=FALSE, out.width= '65%'}
knitr::include_graphics("images/arbre.jpg")
```

> Jeu de données : cernes.txt

```{r}
library(readr)
cernes <- read_csv("../data/cernes.txt")
#View(cernes)

class(cernes) 
#[1] "spec_tbl_df" "tbl_df"      "tbl"         "data.frame" 

cernes_ts <- ts(cernes$Cernes, start = 1.000, frequency = 1) 
cernes_ts

time(cernes_ts) 
plot(cernes_ts) 
acf(cernes_ts)

#cernes.stat <- stat.slide(time(cernes_ts), cernes_ts, xmin = 1.000, deltat = 110)
#cernes.stat
#plot(cernes.stat) 
#ca n'a pas de sens de faire ds statistiques glissantes ici puisque toutes les donnees ont ete collecttionnees la meme année.
```

```{r}
## Identification de tendance à long terme
# Tendance globale
library(pastecs)
# Test par bootstrap
(cernes_trend_test <- trend.test(cernes_ts, R = 999))
#original = coeff correlation, bias = asymétrie, erreur standard= ecart-type par rapport à la distribution normale => le plus important c'est le graphique.
#original= 0.066 : correlation directe négligeable.

plot(cernes_trend_test)
##droite pointillée aux extremes= p faible= p<alpha = on rejette Ho il y a donc une tendance générale.
#qqplot: ronds noirs = observations suivent bien la droite pointillée, donc la distribution est normale.

# Valeur p associée au test bootstrappé
cernes_trend_test$p.value
# Valeur p associée au test bootstrappé : 0,032 < 0,05 -> tendance significative au seuil alpha de 5%
```


```{r}
## Etude de la tendance locale
# Utilisation des sommes cumulées avec local.trend()
cernes.lt <- local.trend(cernes_ts)

#aggrégation des données, on indique 1 car l'unite de temps dans cette serie est de 1.
(cernes2 <- aggregate(cernes_ts, 1/40, mean))
cernes.lt2 <- local.trend(cernes2)
identify(cernes.lt2) 
#La console nous donne : $pos [1]  2  3  4  6  9 12 14 17 20 22 23 (position de points selectionnés). $trends [1]  1.0701000 0.8763750 0.9890750 1.0882667 1.0044750 0.9029625 1.0469667 0.9461250 1.0495375 0.8553250 (pente des segments). $k [1] 0.9866957 (moyenne générale).


## Analyse spectrale : détecte des cycles plus subtils et même des cycles qui se surperposent. qlq soit le signal on peut le représenter par un ensemble de sinus et de cos de periode croissante avec une valeur d'amplitude adéquate à chaque signal. si amplitude des différentes composantes est faible alors signal faible et inversément.
## ## La fréquence est représentée en abscisse et les spectres en ordonnée. Il y a un cycle si un des spectres d’une fréquence différente de zéro se trouve dans la l’intervalle de confiance représenté en haut à droite en bleu.
spectrum(cernes_ts) 
# Technique très puissante, mais signal brut bruité => lissage nécessaire!
# L'argument 'spans' affectue ce lissage, il n'y a pas de règle stictes, il faut juste deux nombres impairs.
spectrum(cernes_ts, spans = c(7, 9))
# Permet de mieux mettre en évidence les pics significatifs. ici il n'y a pas de pics significatifs : tous les pics sont endessous de l'intervalle de confiance.
```


### Variation de la température 
Les chercheurs rencensent la température moyenne mensuelle à Melbourne à partir de janvier 1981. Y a t'il une augmentation de la température au cours du temps ? 

> Jeu de données : temperature_melbourne_1981

```{r,fig.align='center', echo=FALSE, out.width= '65%'}
knitr::include_graphics("images/temperature.jpg")
```

```{r}
library(readr)
temperature_melbourne_1981 <- read_csv("../data/temperature_melbourne_1981.csv")
#View(temperature_melbourne_1981)

class(temperature_melbourne_1981) 

temp_ts <- ts(temperature_melbourne_1981$temp_mean, start = 1981, frequency = 12) 
temp_ts

time(temp_ts) 
plot(temp_ts) 
acf(temp_ts)

cycle(temp_ts)
split(temp_ts, cycle(temp_ts))
boxplot(split(temp_ts, cycle(temp_ts)))

notma.stat <- stat.slide(time(temp_ts), temp_ts, xmin = 1981, deltat = 3)
notma.stat

plot(notma.stat) 

```


```{r}
## Identification de tendance à long terme
# Tendance globale
library(pastecs)
# Test par bootstrap
(temp_trend_test <- trend.test(temp_ts, R = 999))
#original = coeff correlation, bias = asymétrie, erreur standard= ecart-type par rapport à la distribution normale => le plus important c'est le graphique.
#original= 0.026 : correlation direct négligeable.

plot(temp_trend_test)
#droite pointillée au milieu de l'histogramme = p élevé = p > alpha = on ne rejette pas Ho il n'y a donc pas de tendance générale.
#qqplot: ronds noirs = observations suivent bien la droite pointillée, donc la distribution est normale.

# Valeur p associée au test bootstrappé
temp_trend_test$p.value
# Valeur p associée au test bootstrappé : 0.767 > 0,05 -> pas tendance significative au seuil alpha de 5%
```

```{r}
## Etude de la tendance locale
# Utilisation des sommes cumulées avec local.trend()
temp.lt <- local.trend(temp_ts)
#les cycles perturbent l'analyse on utilise donc aggregate pour contrer cela.
(temp2 <- aggregate(temp_ts, 1, mean))

temp.lt2 <- local.trend(temp2)
identify(temp.lt2) 
# #La console nous donne : $pos [1]  1  2  3  4  5  7  8  9 10 (position de points selectionnés). $trends [1] 10.80808 11.21565 10.61205 11.15383 10.84979 11.98291 11.29086 11.68987 (pente des segments). $k [1] 11.2008 (moyenne générale).


## Analyse spectrale : détecte des cycles plus subtils et même des cycles qui se surperposent. qlq soit le signal on peut le représenter par un ensemble de sinus et de cos de periode croissante avec une valeur d'amplitude adéquate à chaque signal. si amplitude des différentes composantes est faible alors signal faible et inversément.
## ## La fréquence est représentée en abscisse et les spectres en ordonnée. Il y a un cycle si un des spectres d’une fréquence différente de zéro se trouve dans la l’intervalle de confiance représenté en haut à droite en bleu.
spectrum(temp_ts) 
# Technique très puissante, mais signal brut bruité => lissage nécessaire!
# L'argument 'spans' affectue ce lissage, il n'y a pas de règle stictes, il faut juste deux nombres impairs.
spectrum(temp_ts, spans = c(3, 5))
# Permet de mieux mettre en évidence les pics significatifs. ici il y a un pic significatif : a la frequence 1.
```

### Transect de Nice à Calvi

Les chercheurs souhaitent visualiser graphiquement la distribution des Copépodes le long du transect (Variable Copepodits1).

```{r, echo= FALSE, message=FALSE, out.width= '50%', fig.align='center'}
library(tidyverse)
library(cowplot)
fr <- map_data("france")
ggplot(fr, aes(long, lat, group = group)) +
  geom_polygon(fill= "white", color = "black") +
  geom_segment(aes(y = 43.7 , x = 7.25, yend = 42.56, xend= 8.75, color = "red"), size = 1, show.legend = FALSE) +
  theme(axis.line = element_blank(), axis.title = element_blank(),axis.text = element_blank(), axis.ticks = element_blank()) +
  coord_quickmap()
```

```{r}
library(readr)
data(marbio)
marbio

class(marbio) 

marbio_ts <- ts(marbio$Copepodits1, start = 1.000, frequency = 1) 
marbio_ts

time(marbio_ts) 
plot(marbio_ts) 
acf(marbio_ts)
```


```{r}
## Identification de tendance à long terme
# Tendance globale
library(pastecs)
# Test par bootstrap
(marbio_trend_test <- trend.test(marbio_ts, R = 999))
#original = coeff correlation, bias = asymétrie, erreur standard= ecart-type par rapport à la distribution normale => le plus important c'est le graphique.
#original= 0.68 : correlation direct non négligeable.

plot(marbio_trend_test)
##droite pointillée aux extremes= p faible= p<alpha = on rejette Ho il y a donc une tendance générale.
#qqplot: ronds noirs = observations suivent bien la droite pointillée, donc la distribution est normale.

# Valeur p associée au test bootstrappé
marbio_trend_test$p.value
# Valeur p associée au test bootstrappé : 0 < 0,05 -> tendance significative au seuil alpha de 5%
```

```{r}
## Etude de la tendance locale
# Utilisation des sommes cumulées avec local.trend()
marbio.lt <- local.trend(marbio_ts)
#en pointillé on voit la série initiale. la courbe rouge (=sommes cumulées) chaque segment de la ligne brisée représente une tendance locale : une période où la moyenne ne varie pas: la valeur de cette moyenne est donnée par la pente du segment additionnée de r (=moyenne de toute la série).Par rapport à la moyenne globale des observations, soit on est au-dessus ou en-dessous.

identify(marbio.lt)
# ATTENTION: identify() ne peut PAS être utilisée dans un R Markdown ou Notebook. Cette fonction doit être utilisée seulement dans le fenêtre CONSOLE de R!!!
#Selectionner cette ligne de code avec la précédente avec d'executer (Ctrl+Enter). Cliquer les points voulus (dans ce graphe-ci un point au début, un au milieu qd est T° très basses et un point à la fin), puis indiquer "finish"...
#La console nous donne : $pos [1]  1 32 40 47 51 60 62 (position de points selectionnés). $trends [1] 35.03226 263.50000 119.71429 294.00000 106.77778 352.00000 (pente des segments). $k [1] 112.8676 (moyenne générale).


## Analyse spectrale : détecte des cycles plus subtils et même des cycles qui se surperposent. qlq soit le signal on peut le représenter par un ensemble de sinus et de cos de periode croissante avec une valeur d'amplitude adéquate à chaque signal. si amplitude des différentes composantes est faible alors signal faible et inversément.
## ## La fréquence est représentée en abscisse et les spectres en ordonnée. Il y a un cycle si un des spectres d’une fréquence différente de zéro se trouve dans la l’intervalle de confiance représenté en haut à droite en bleu.
spectrum(marbio_ts) 
# Technique très puissante, mais signal brut bruité => lissage nécessaire!
# L'argument 'spans' affectue ce lissage, il n'y a pas de règle stictes, il faut juste deux nombres impairs.
spectrum(marbio_ts, spans = c(3, 5))
# Permet de mieux mettre en évidence les pics significatifs. ici il y a un pic significatif : a la frequence 0.2.
```


> Jeu de données : Marbio du package (Pastecs)

### Production de lait 

La production mensuelle de lait par vache est monitoré à partir de janvier 1926. Y a t'il une évolution linéaire? Le cycle annuel est modélisable ? 

```{r,fig.align='center', echo=FALSE, out.width= '65%'}
knitr::include_graphics("images/vache.jpg")
```




```{r}
library(readr)
milK_product_1962 <- read_csv("../data/milK_product_1962.csv")
milK_product_1962


class(milK_product_1962) 

milK_ts <- ts(milK_product_1962$product, start = 1962, frequency = 12) #on met f=1 car pas précisé, une observation par jour.
milK_ts

time(milK_ts) 
plot(milK_ts) 
acf(milK_ts)

cycle(milK_ts)
split(milK_ts, cycle(milK_ts))
boxplot(split(milK_ts, cycle(milK_ts)))


milk.stat <- stat.slide(time(milK_ts), milK_ts, xmin = 1962, deltat = 6)
milk.stat

plot(milk.stat) 

```

```{r}
## Identification de tendance à long terme
# Tendance globale
library(pastecs)
# Test par bootstrap
(milK_trend_test <- trend.test(milK_ts, R = 999))
#original = coeff correlation, bias = asymétrie, erreur standard= ecart-type par rapport à la distribution normale => le plus important c'est le graphique.
#original= 0.816 : correlation direct non négligeable.

plot(milK_trend_test)
##droite pointillée aux extremes= p faible= p<alpha = on rejette Ho il y a donc une tendance générale.
#qqplot: ronds noirs = observations suivent bien la droite pointillée, donc la distribution est normale.

# Valeur p associée au test bootstrappé
milK_trend_test$p.value
# Valeur p associée au test bootstrappé : 0 < 0,05 ->  tendance significative au seuil alpha de 5%
```


```{r}
## Etude de la tendance locale
# Utilisation des sommes cumulées avec local.trend()
milK.lt <- local.trend(milK_ts)
#en pointillé on voit la série initiale. la courbe rouge (=sommes cumulées) chaque segment de la ligne brisée représente une tendance locale : une période où la moyenne ne varie pas: la valeur de cette moyenne est donnée par la pente du segment additionnée de r (=moyenne de toute la série).Par rapport à la moyenne globale des observations, soit on est au-dessus ou en-dessous. Au debut les variations sont bruitées, on utilise donc aggregate pour contrer cela. 

identify(milK.lt)
#La console nous donne : $pos [1] 1  73 155 (position de points selectionne). $trends [1] 671.8389 813.4610 (pente des segments). $k [1] 746.4917 (moyenne générale).


## Analyse spectrale : détecte des cycles plus subtils et même des cycles qui se surperposent. qlq soit le signal on peut le représenter par un ensemble de sinus et de cos de periode croissante avec une valeur d'amplitude adéquate à chaque signal. si amplitude des différentes composantes est faible alors signal faible et inversément.
## ## La fréquence est représentée en abscisse et les spectres en ordonnée. Il y a un cycle si un des spectres d’une fréquence différente de zéro se trouve dans la l’intervalle de confiance représenté en haut à droite en bleu.
spectrum(milK_ts) 
# Technique très puissante, mais signal brut bruité => lissage nécessaire!
# L'argument 'spans' affectue ce lissage, il n'y a pas de règle stictes, il faut juste deux nombres impairs.
spectrum(milK_ts, spans = c(3, 5))
# Permet de mieux mettre en évidence les pics significatifs. ici il y a un pic significatif : a la frequence 1.
```


> Jeu de données : milk_product_1962

### Variation de la population en Australie

Les chercheurs rencensent mensuellement le population Australienne à partir de 1978. Ils souhaitent savoir si la croissance a été linéaire. 

> jeu de données : demographie.txt

```{r,fig.align='center', echo=FALSE, out.width= '65%'}
knitr::include_graphics("images/australie.jpg")
```

```{r}
library(readr)
demographie <- read_csv("../data/demographie.txt")
#View(demographie)

class(demographie) 

demo_ts <- ts(demographie$population, start = 1978, frequency = 12) 
demo_ts

time(demo_ts) 
plot(demo_ts)
acf(demo_ts) 


demo.stat <- stat.slide(time(demographie_ts), demographie_ts, xmin = 1978, deltat = 6)
demo.stat

plot(demo.stat) 
```



```{r}
## Identification de tendance à long terme
# Tendance globale
library(pastecs)
# Test par bootstrap
(demo_trend_test <- trend.test(demo_ts, R = 999))
#original = coeff correlation, bias = asymétrie, erreur standard= ecart-type par rapport à la distribution normale => le plus important c'est le graphique.
#original= 1 : correlation direct maximale.

plot(demo_trend_test)
##droite pointillée aux extremes= p faible= p<alpha = on rejette Ho il y a donc une tendance générale.
#qqplot: ronds noirs = observations suivent bien la droite pointillée, donc la distribution est normale.

# Valeur p associée au test bootstrappé
demo_trend_test$p.value
# Valeur p associée au test bootstrappé : 0 < 0,05 -> tendance significative au seuil alpha de 5%
```

```{r}
## Etude de la tendance locale
# Utilisation des sommes cumulées avec local.trend()
demo.lt <- local.trend(demo_ts)
#en pointillé on voit la série initiale. la courbe rouge (=sommes cumulées) chaque segment de la ligne brisée représente une tendance locale : une période où la moyenne ne varie pas: la valeur de cette moyenne est donnée par la pente du segment additionnée de r (=moyenne de toute la série).Par rapport à la moyenne globale des observations, soit on est au-dessus ou en-dessous.

identify(demo.lt)
# ATTENTION: identify() ne peut PAS être utilisée dans un R Markdown ou Notebook. Cette fonction doit être utilisée seulement dans le fenêtre CONSOLE de R!!!
#Selectionner cette ligne de code avec la précédente avec d'executer (Ctrl+Enter). Cliquer les points voulus (dans ce graphe-ci un point au début, un au milieu qd est T° très basses et un point à la fin), puis indiquer "finish"...
#La console nous donne : $pos [1] 1 86 158 (position de points selectionnés). $trends [1] 11195.76 12708.81 (pente des segments). $k [1] 11890.66 (moyenne générale).


## Analyse spectrale : détecte des cycles plus subtils et même des cycles qui se surperposent. qlq soit le signal on peut le représenter par un ensemble de sinus et de cos de periode croissante avec une valeur d'amplitude adéquate à chaque signal. si amplitude des différentes composantes est faible alors signal faible et inversément.
## ## La fréquence est représentée en abscisse et les spectres en ordonnée. Il y a un cycle si un des spectres d’une fréquence différente de zéro se trouve dans la l’intervalle de confiance représenté en haut à droite en bleu.
spectrum(demo_ts) 
# Technique très puissante, mais signal brut bruité => lissage nécessaire!
# L'argument 'spans' affectue ce lissage, il n'y a pas de règle stictes, il faut juste deux nombres impairs.
spectrum(demo_ts, spans = c(3, 5))
# Permet de mieux mettre en évidence les pics significatifs. ici il n'y a pas de pics significatifs : tous les pics sont endessous de l'intervalle de confiance.
```


